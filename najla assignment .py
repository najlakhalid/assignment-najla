# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vq90q23qOAye_ty0tnz0I-VdzFasO4pZ
"""

class Chocolate:
    def __init__(self, weight, price, type, id):
        self.weight = weight
        self.price = price
        self.type = type
        self.id = id

    def __repr__(self):
        return f"Chocolate(weight={self.weight}, price={self.price}, type='{self.type}', id={self.id})"

# Defining the iterative function of chocolates to students
def chocolates_iteratively(chocolates, students):
    distribution = {}
    for student in students:
        if chocolates:
            distribution[student] = chocolates.pop(0)
        else:
            distribution[student] = None
    return distribution

# Defining the recursive function of chocolates to students
def chocolates_recursively(chocolates, students, distribution=None, index=0):
    if distribution is None:
        distribution = {}

    if index < len(students):
        student = students[index]
        if chocolates:
            distribution[student] = chocolates.pop(0)
            return chocolates_recursively(chocolates, students, distribution, index + 1)
        else:
            distribution[student] = None
            return chocolates_recursively(chocolates, students, distribution, index + 1)
    else:
        return distribution

# Example test cases
chocolates = [Chocolate(8, 3, 'Hazelnut', '003'), Chocolate(10, 5, 'Caramel', '006')]
students = ['Hamda', 'Ali', 'Sara', 'Najla']

iterative_distribution = chocolates_iteratively(chocolates[:], students)
recursive_distribution = chocolates_recursively(chocolates[:], students)

print("Iterative Distribution:")
for student, chocolate in iterative_distribution.items():
    print(f"{student}: {chocolate}")

print("\nRecursive Distribution:")
for student, chocolate in recursive_distribution.items():
    print(f"{student}: {chocolate}")

# Defining Quick Sort for sorting chocolates by weight
def quick_sort_by_weight(chocolates):
    if len(chocolates) <= 1:
        return chocolates
    else:
        pivot = chocolates[0].weight
        less = [choc for choc in chocolates[1:] if choc.weight <= pivot]
        greater = [choc for choc in chocolates[1:] if choc.weight > pivot]
        return quick_sort_by_weight(less) + [chocolates[0]] + quick_sort_by_weight(greater)

# Defining Merge Sort for sorting chocolates by price
def merge_sort_by_price(chocolates):
    if len(chocolates) <= 1:
        return chocolates

    middle = len(chocolates) // 2
    left = merge_sort_by_price(chocolates[:middle])
    right = merge_sort_by_price(chocolates[middle:])

    return merge(left, right)

def merge(left, right):
    result = []
    left_index_type = right_index_type = 0

    while left_index_type < len(left) and right_index_type < len(right):
        if left[left_index_type].price <= right[right_index_type].price:
            result.append(left[left_index_type])
            left_index_type += 1
        else:
            result.append(right[right_index_type])
            right_index_type += 1

    result += left[left_index_type:]
    result += right[right_index_type:]
    return result

# Test cases for sorting
chocolates = [
    Chocolate(5, 2, 'Almond', '002'),
    Chocolate(7, 4, 'Peanut Butter', '005'),
    Chocolate(3, 3, 'Milk', '003'),
    Chocolate(6, 1, 'Dark', '004'),
    Chocolate(8, 5, 'Hazelnut', '001'),
]

sorted_by_weight = quick_sort_by_weight(chocolates)
sorted_by_price = merge_sort_by_price(chocolates)

print("\nSorted by Weight:")
for chocolate in sorted_by_weight:
    print(chocolate)

print("\nSorted by Price:")
for chocolate in sorted_by_price:
    print(chocolate)

# Binary search algorithm to find chocolate by weight or price
def binary_search_chocolates(chocolates, key, search_by='weight'):
    low = 0
    high = len(chocolates) - 1

    while low <= high:
        mid = (low + high) // 2
        if search_by == 'weight':
            if chocolates[mid].weight == key:
                return chocolates[mid]
            elif chocolates[mid].weight < key:
                low = mid + 1
            else:
                high = mid - 1
        elif search_by == 'price':
            if chocolates[mid].price == key:
                return chocolates[mid]
            elif chocolates[mid].price < key:
                low = mid + 1
            else:
                high = mid - 1
    return None

# Additional test cases for searching
search_weight = 6  # Searching for a chocolate with weight 6g
search_price = 2  # Searching for a chocolate with price 2 AED

# Test case 1: Search for a chocolate with weight 6g
search_weight_6 = binary_search_chocolates(sorted_by_weight, search_weight)
print("\nFound by Weight (6g):", search_weight_6)

# Test case 2: Search for a chocolate with weight 10g (not in the list)
search_weight_10 = binary_search_chocolates(sorted_by_weight, 10)
print("Found by Weight (10g):", search_weight_10)

# Test case 3: Search for a chocolate with price 2 AED
search_price_2 = binary_search_chocolates(sorted_by_price, search_price, search_by='price')
print("Found by Price (2 AED):", search_price_2)

# Test case 4: Search for a chocolate with price 5 AED (not in the list)
search_price_5 = binary_search_chocolates(sorted_by_price, 5, search_by='price')
print("Found by Price (5 AED):", search_price_5)